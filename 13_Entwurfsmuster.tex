\section{Entwurfsmuster}
\definition[0]{Software-Entwurfsmuster}{Ein Software-Entwurfsmuster beschreibt eine Familie von \important{Lösungen} für ein Software-\important{Entwurfsproblem}.}
\anmerkung[0]{}{Der Zweck von Entwurfsmustern ist die Wiederverwendung von Entwurfswissen.}
\\
Sie dienen außerdem:
\begin{itemize}
    \item die Kommunikation im Team zu verbessern, da sie eine nützliche Terminologie bieten
    \item der Verständlichkeit indem sie helfen Entwürfe zu verstehen, sie kurz und knapp zu dokumentieren und Architektur-Drift verhindern
    \item dem Flexen mit Entwurfswissen
\end{itemize}

\subsection{Schnelle Übersicht}
\begin{table}[h]
\begin{tabular}{l|l}
Kategorie & Muster   \\\hline
Entkopplungsmuster & Adapter, Beobachter, Brücke, Iterator, Stellvertreter, Vermittler  \\
Variantenmuster & Abstrakte Fabrik, Besucher, Fabrikmethode, Kompositum, \\& Schablonenmethode, Strategie, Dekorierer \\
Zustandshandhabungsmuster & Einzelstück, Fliegengewicht, Memento, Prototyp, Zustand  \\
Steuerungsmuster & Befehl, Master/Slave (Master/Worker)  \\
Virtuelle Maschinen &   \\
Bequemlichkeitsmuster & Bequemlichkeitsklasse, Bequemlichkeitsmethode, Fassade, Null-Objekt 
\end{tabular}
\end{table}
\newpage
\subsection{Entkopplungs-Muster}
\definition[1]{Entkopplungs-Muster}{Entkopplungsmuster teilen ein System in mehrere Einheiten, so dass einzelne Einheiten unabhängig voneinander erstellt, verändert, ausgetauscht und wiederverwendet werden können. Der Vorteil von Entkopplungsmustern ist, dass ein System durch lokale Änderungen verbessert, angepasst und erweitert werden kann, ohne das ganze System zu modifizieren.}
% Adapter
\subsubsection{Adapter}
\definition[0]{Adapter}{Passt die Schnittstelle einer Klasse an eine Andere von ihren Klienten erwartete Schnittstelle an.}
\anmerkung[0]{}{$\Rightarrow$ Klassen können zusammenarbeiten, die wegen inkompatibler Schnittstelle ansonsten nicht in der Lage wären.}
\fig{Adapter ohne Mehrfachvererbung}{./data/entwurfsmuster/entkopplungsmuster/adapter_1.png}
\fig{Adapter mit Mehrfachvererbung}{./data/entwurfsmuster/entkopplungsmuster/adapter_2.png}
\newpage
\subsubsection{Beobachter / Observer}
\definition[0]{Beobachter}{Ein Beobachter beobachtet ein Objekt und informiert andere Objekte über Änderungen an diesem.}
\anmerkung[0]{}{Ein Beobachter definiert eine 1-zu-n Abhängigkeit zwischen Objekten, so dass die Änderung eines Zustandes eines Objektes dazu führt, dass alle abhängigen Objekte benachrichtigt und automatisch aktualisiert werden.}
\newline
\fig{Struktur eines Beobachters}{./data/entwurfsmuster/entkopplungsmuster/observer_1.png}
\newline
\fig{Beobachter - Beispiel aus Java}{./data/entwurfsmuster/entkopplungsmuster/observer_2.png}
\anmerkung[0]{Anwendbarkeit}{Wenn die Änderung eines Objekts die Änderung anderer Objekte verlangt und man nicht weiß, wie viele und welche Objekte geändert werden müssen.}
\anmerkung[1]{}{Wenn ein Objekt andere Objekte benachrichtigen muss, ohne Annahmen über diese Objekte zu treffen.}
\anmerkung[0]{Konsequenzen}{Beobachter können neu hinzugefügtoder entferntwerden, ohnedas Subjekt oder andere Beobachter zu ändern}
 
\subsubsection{Brücke / Bridge}
\definition[0]{Brücke}{Die Brücke trennt Abstraktion von ihrer Implementierung, sodass beide unabhängig voneinander variiert werden können.}
\fig{Brücke}{./data/entwurfsmuster/entkopplungsmuster/bridge.png}
\\
Anwendbarkeit:
\begin{itemize}
    \item Wenn eine dauerhafte Verbindung zwischen Abstraktion und Implementierung vermieden werden soll
    \item Wenn Erweiterbarkeit durch Unterklassen für beide Seiten gefordert ist
    \item Wenn Änderungen der Implementierung einer Abstraktion keine Auswirkung auf Klienten haben soll
    \item Wenn die Implementierung der Abstraktion vollständig vom Klienten versteckt werden sollen.
\end{itemize}
\fig{Beispiel für ein Brückenmuster}{./data/entwurfsmuster/entkopplungsmuster/bridge_example.png}
\newpage
\subsubsection{Iterator}
\definition[1]{Iterator}{Ein Iterator ermöglicht einen \important{sequentiellen Zugriff} auf die Elemente eines zusammengesetzten Objektes, ohne seine zugrundeliegendes Repräsentation offenzulegen.}
\fig{Struktur eines Iterators}{./data/entwurfsmuster/entkopplungsmuster/iterator_1.png}
\warn[0]{}{Ein Iterator funktioniert immer sequenziell}
\anmerkung[0]{}{Das momentane Element kann aus der Datenstruktur entfernt werden.}
\anmerkung[0]{Anwendbarkeit}{Um den Zugriff auf den Inhalt eines zusammengesetzten Objekts zu ermöglichen, ohne dabei seine interne Struktur offenzulegen.}
\anmerkung[0]{}{Robust ist der Iterator, weil er gleichzeitig mehrere Traversierungen ermöglicht. Jeder Iterator enthält eine eigene „Laufvariable“.}

\newpage
\subsubsection{Stellvertreter / Proxy}
\definition[0]{Stellvertreter}{Ein Proxy kontrolliert den Zugriff auf ein Objekt mit Hilfe eines vorgelagerten \important{Stellvertreterobjekts}}
\fig{Struktur eines Stellvertreters}{./data/entwurfsmuster/entkopplungsmuster/proxy_1.png}
\anmerkung[0]{Anwendbarkeit}{Das Stellvertretermuster ist anwendbar, sobald es den Bedarf nach einer anpassungsfähigeren und intelligenteren Referenz auf ein Objekt als einen einfachen Zeiger gibt}
\subsubsection{Vermittler / Mediator}
\definition[0]{Vermittler}{Ein Vermittler definiert ein Objekt, welches das \important{Zusammenspiel} einer Menge von Objekten in sich Kapselt}
\anmerkung[0]{}{Vermittler fördern \important{lose Kopplung}, indem sie Objekte davon abhalten, aufeinander explizit Bezug zu nehmen. Sie ermöglichen es, das Zusammenspiel der Objekte unabhängig zu variieren.}
\fig{Struktur eines Vermittlers}{./data/entwurfsmuster/entkopplungsmuster/vermittler_1.png}
\anmerkung[0]{Anwendbarkeit}{Wenn eine Menge von Objekten vorliegt, die in wohl-definierter, aber \important{komplexer} Weise zusammen arbeiten. Die sich ergebenden Abhängigkeiten sind unstrukturiert und schwer zu verstehen.}

\newpage

\subsection{Varianten-Muster}

\definition[0]{Varianten-Muster}{Fassen Gemeinsamkeiten von verwandten Elementen an einer einzigen Stelle zusammen. Hierdurch können unterschiedliche Komponenten einheitlich verwendet werden und Wiederholungen desselben Codes werden vermieden.}

\subsubsection{Strategie}
\definition[0]{Strategie}{Eine Strategie definiert eine Familie von Algorithmen, kapselt sie und macht sie austauschbar. Das Strategiemuster ermöglicht es, den Algorithmus unabhängig von den nutzenden Klienten zu variieren.}

\fig{Struktur einer Strategie}{./data/entwurfsmuster/variantenmuster/strategie_1.png}

\fig{Beispiel einer Strategie [Anhand von Zeilenumbrechalgorithmen]}{./data/entwurfsmuster/variantenmuster/strategie_example.png}

\anmerkung[0]{Anwendbarkeit}{
    \begin{itemize}
        \item Wenn unterschiedliche Varianten eines Algorithmus benötigt werden.
        \item Wenn ein Algorithmus Datenstrukturen verwendet, die Klienten nicht bekannt sein sollen.
        \item Wenn eine Klasse unterschiedliche Verhaltensweisen definiert und diese als mehrfache Fallunterscheidungen in ihren Operationen erscheinen. Mit Strategie kann man diese Fallunterscheidungen vermeiden (\anfuehrung{switchless programming}).
    \end{itemize} $\>$
}

\subsubsection{Schablonenmethode}
\definition[0]{Schablonenmethode}{Es wird ein Skelett eines Algorithmus als eine Operation definiert um einzelne Schritte an Unterklassen zu delegieren. Es ermöglicht die Änderung der Teilschritte in den Unterklassen ohne die Struktur des Algorithmus zu verändern}
\fig{Schablonenmethodendiagramm}{./data/entwurfsmuster/variantenmuster/templatemethod.png}
\\
Die Schablonenmethode eignet sich, wenn...
\begin{itemize}
    \item die invarianten Teile eines Algorithmus genau einmal festgelegt werden können
    \item Code-Duplikate von Teilalgorithmen vermieden werden sollen
\end{itemize}

\newpage
\subsubsection{Fabrikmethode}
\definition[0]{Fabrikmethode}{Eine Fabrikmethode definiert eine Klassenschnittstelle mit Operationen zum Erzeugen eines Objekts aber lässt Unterklassen entscheiden, \important{von welcher Klasse} das zu erzeugende Objekt ist. Fabrikmethoden ermöglichen es einer Klasse, die Erzeugung von Objekten an Unterklassen zu \important{delegieren}.}

\fig{Struktur einer Fabrikmethode}{./data/entwurfsmuster/variantenmuster/fabrikmethode_1.png}

\fig{Fabrikmethode - Beispiel anhand von Wänden}{./data/entwurfsmuster/variantenmuster/fabrikmethode_example.png}

Anwendbar, wenn
\begin{itemize}
    \item die Klasse die Klasse seiner zu erzeugenden Objekte nicht im voraus kennen kann
    \item eine Klasse möchte, dass ihre Unterklassen festlegen, welche Objekte erzeugt werden sollen
\end{itemize}

\newpage
\subsubsection{Abstrakte Fabrik (engl. abstract factory)}
\definition[1]{Abstrakte Fabrik}{Bietet eine Schnittstelle zum \important{Erzeugen von Familien} verwandter oder voneinander abhängiger Objekte, ohne ihre konkreten Klassen zu benennen.}

\fig{Struktur einer abstakten Fabrik}{./data/entwurfsmuster/variantenmuster/abstake_fabrik_1.png}

% \fig{Abstrakte Fabrik - Beispiel anhand einer Widget-Fabrik}{./data/entwurfsmuster/variantenmuster/abstake_fabrik_example.png}
\fig{Abstrakte Fabrik - Beispiel anhand von Pizza}{./data/entwurfsmuster/variantenmuster/abstake_fabrik_example2.png}

Anwendbar, wenn
\begin{itemize}
    \item ein System \important{unabhängig} davon sein soll, wie seine Produkte erzeugt, zusammengesetzt und repräsentiert werden.
    \item Wenn ein System mit einer von mehreren \important{Produktfamilien} konfiguriert werden soll.
    \item Bei einer Klassenbibliothek, die nur die Schnittstellen, nicht aber die Implementierung offenlegt.
\end{itemize}
\newpage
\subsubsection{Besucher (engl. visitor)}
\definition[1]{Besucher}{Ein Besucher kapselt eine auf eine Objektstruktur auszuführende \important{Operation} als ein Objekt}

\fig{Struktur eines Besuchers}{./data/entwurfsmuster/variantenmuster/besucher_1.png}

\fig{Beispiel eines Besuchers anhand eines Abstrakten Syntaxbaumes}{./data/entwurfsmuster/variantenmuster/besucher_example.png}

Anwendbar, wenn
\begin{itemize}
    \item eine Objektstruktur viele Klassen von Objekten mit unterschiedlichen Schnittstellen enthält und Operationen auf diesen ausgeführtt werden sollen, die von ihren konkreten Klassen abhängen
    \item mehrere unterschiedliche und nicht miteinander verwandte Operationen auf den Objekten einer Objektstruktur Objektstruktur ausgeführt werden müssen und diese Klassen nicht mit dieser Operation "verschmutzt" werden sollen
\end{itemize}

\subsubsection{Kompositum}
\definition[0]{Kompositum}{Fügt Objekte zu Baumstrukturen zusammen, um Bestands-Hierarchien zu repräsentieren. Ermöglicht es Klienten sowohl einzelne Objekte als auch Aggregate einheitlich zu behandeln.}

\fig{Struktur eines Kompositums}{./data/entwurfsmuster/variantenmuster/kompositum_1.png}

\fig{Beispiel eines Kompositums anhand von Java AWT}{./data/entwurfsmuster/variantenmuster/kompositum_example.png}

Anwendbarkeit:
\begin{itemize}
    \item Wenn Bestands-Hierarchien von Objekten repräsentiert werden sollen.
    \item Wenn die Klienten in der Lage sein sollen, die Unterschiede zwischen zusammengesetzten und einzelnen Objekten zu ignorieren.
\end{itemize}
\newpage
\subsubsection{Dekorierer}
\definition[0]{Dekorierer}{Fügt einem Objekt dynamisch neue Funktionalität hinzu}

\fig{Struktur des Dekorier-Modells}{./data/entwurfsmuster/variantenmuster/decorator.png}

Für was der Dekorierer gut ist...
\begin{itemize}
    \item Objektfunktionalität hinzufügen, ohne Subjekt zu ändern
    \item Kann Subjektschnittstelle erweitern
\end{itemize}

Und wo der Stellvertreter eingesetzt wird...
\begin{itemize}
    \item Zugriffssteuerung
    \item Kann genauso wie ein Subjekt verwendet werden
    \item Latenz und Methoden verstecken
    \item Eigenes Objekt mit Subjekt im Hintergrund
\end{itemize}

\newpage
\subsection{Zustandshandhabungs-Muster}

\definition[0]{Zustandshandhabungs-Muster}{Die Muster dieser Kategorie bearbeiten den Zustand von Objekten, unabhängig von deren Zweck.}

\subsubsection{Einzelstück}

\definition[0]{Einzelstück}{Zusicherung, dass eine Klasse genau ein Exemplar besitzt und globalen Zugriffspunkt bereitstellen (getInstance())}

\fig{Einzelstückmusterstruktur}{./data/entwurfsmuster/zustandshandhabungsmuster/singelton.png}

Anwendbar, wenn...
\begin{itemize}
    \item es von einem Objekt nur eine Instanz geben darf und diese an einer bestimmten Stelle zugänglich gemacht werden soll
    \item es schwierig oder unmöglich ist festzustellen, welcher Teil der Anwendung die erste Instanz erzeugt
    \item die Instanz durch Unterklassenbildung erweiterbar sein soll und die Klienten ohne Veränderung ihres Quelltextes diese nutzen sollen
\end{itemize}


\subsubsection{Fliegengewicht (engl. flyweight)}
\definition[0]{Fliegengewicht}{Nutze Objekte kleinster Granularität gemeinsam, um große Mengen von ihnen effizient speichern zu können}
\fig{Fliegengewichtmusterstruktur}{./data/entwurfsmuster/zustandshandhabungsmuster/flyweight.png}
Anwendbar, wenn
\begin{itemize}
    \item Speicherkosten hoch sind und große Mengen gespeichert werden
    \item ein Großteil des Objektzustandes in den Kontext verlegt werden kann
    \item die Anwendung nicht von der Identität des Objekts abhängt
\end{itemize}



\subsubsection{Memento (engl. memento)}
\definition[0]{Memento}{Erfasst und \important{externalisiert} den \important{internen Zustand} eines Objekts, ohne seine Kapselung zu verletzzen, do dass das Objekt später in diesen Zustand zurückversetzt werden kann.}
\fig{Mementomusterstruktur}{./data/entwurfsmuster/zustandshandhabungsmuster/memento.png}
Anwendbar, wenn...
\begin{itemize}
    \item eine \important{Momentaufnahme} eines Teils des Zustands eines Objekts zwischengespeichertwerden muss, so dass es zu einem späteren Zeitpunkt in diesen Zustand zurückversetzt werden kann
    \item eine direkte Schnittstelle zum Ermitteln des Zustands die Implementierungsdetails offenlegen und die Kapselung des Objekts aufbrechen würde
\end{itemize}

\subsubsection{Prototyp}
\definition[0]{Prototyp}{Bestimme die Art der zu erzeugenden Objekte anhand eines typischen Objekts und erstelle neue Objekte durch Kopieren dieses Prototyps}
\fig{Prototypenmusterstruktur}{./data/entwurfsmuster/zustandshandhabungsmuster/prototype.png}
Andwendbar, wenn
\begin{itemize}
    \item der Aufbau eines Objektes wesentlich mehr Zeit braucht als eine Kopie davon anzulegen
    \item das System unabhängig von der Objekterzeugung, -represäntatition und -zusammensetzung sein soll
    \item um Fabrikhierarchien parallel zur Klassenhierarchie der Produkte zu vermeiden
    \item die Klassen der zu erstellenden Objekten erst zur Laufzeit feststehen
\end{itemize}


\subsubsection{Zustand}
\definition[0]{Zustand (engl. state)}{Ändert das \important{Verhalten} des Objektes, wenn sich dessen interner Zustand ändert.}
\fig{Zustandsmusterstruktur}{./data/entwurfsmuster/zustandshandhabungsmuster/zustand.png}
Anwendbar, wenn
\begin{itemize}
    \item das Verhaltendes Objektes von dessen Zustand abhängt und das Objekt sein Verhalten während der Laufzeit, abhängig vom aktuellen Zustand, ändern muss
\end{itemize}

\definition[0]{Implizite Speicherung}{Der Zustand wird aus Attributen berechnet und nicht explizit gespeichert}
\definition[0]{Explizite Speicherung}{Der Zustand wird durch eine separate Instanzvariable gespeichert. Hierfür benötigt es eine explizite Zustandsüberführungsfunktion}
\definition[0]{Eingebettete Speicherung}{Die Methoden einer Klasse kennen den gesamten Automaten und sorgen für die Zustandswechsel}
\definition[0]{Ausgelagerte Speicherung}{Zustände werden als separate Objekte modelliert, worin die Methoden laufen}

\subsection{Steuerungs-Muster}

\definition[0]{Steuerungs-Muster}{Steuerungsmuster steuern den Kontrollfluss. Sie bewirken, dass zur richtigen Zeit die richtigen Methoden aufgerufen werden}

\subsubsection{Befehl (engl. command)}

\definition[0]{Command}{Kapselt einen Befehl als ein Objekt. Dies ermöglicht es, Klienten mit verschiedenen Anfragen zu parametrisieren, Operationen in eine Warteschlange zu stellen, ein Logbuch zu führen und Operationen rückgängig zu machen.}
\fig{Steuerungsmusterstruktur}{./data/entwurfsmuster/steuerungsmuster/command.png}
Anwendbar, wenn...
\begin{itemize}
    \item Objekte mit einer auszuführenden Aktion parametrisiertwerden sollen (wie bei den MenüEintrag-Objekten)
    \item Anfragen zu unterschiedlichen Zeiten spezifiziert, aufgereiht und ausgeführt werden sollen
    \item ein Rückgängigmachenvon Operation (Undo) unterstützt werden soll
    \item das Mitprotokollierenvon Änderungen unterstützt werden soll (um System nach Absturz wiederherzustellen)
    \item ein System mittels komplexer Operationen strukturiert werden soll, die aus primitiven Operationen aufgebaut werden (Makrobefehle)
\end{itemize}

\subsubsection{Auftraggeber/-nehmer (engl. master/worker)}
\definition[0]{Auftraggeber/-nehmer}{bietet \important{fehlertolerante} und parallele Berechnung. Ein Auftraggeber verteilt die Arbeit an identische Arbeiter (Auftragnehmer) und berechnet das Endergebnis aus den Teilergebnissen, welche die Arbeiter zurückliefern}
\fig{Auftraggeber/-nehmerstrukturmusterstruktur}{./data/entwurfsmuster/steuerungsmuster/masterslave.png}
Anwendbar, wenn...
\begin{itemize}
    \item es mehrere Aufgaben gibt, die unabhängigvoneinander bearbeitet werden können.
    \item mehrere Prozessorenzur parallelen Verarbeitung zur Verfügung stehen.
    \item die Belastung der Arbeiter ausgeglichenwerden soll.
\end{itemize}

\newpage
\subsection{Bequemlichkeitsmuster}
\definition[0]{Bequemlichkeitsmuster}{Entwurfsmuster, die etwas Schreib- oder Denkarbeit sparen.}
\subsubsection{Bequemlichkeitsklasse}
\definition[0]{Bequemlichkeitsklasse}{Vereinfachen von Methodenaufrufe durch Bereithaltung der Parameter (Standardwerte) in einer speziellen Klasse. Also quasi Methoden überladen und dann Standardwerte für die fehlenden Parameter verwenden}.
\fig{Bequemlichkeitsklassenmusterstruktur}{./data/entwurfsmuster/bequemlichkeitsmuster/bequemlichkeitsklasse.png}
Anwendbar, wenn
\begin{itemize}
    \item Methodenaufrufe vereinfacht werden sollen, in dem häufig gleich verwendete Parameter mit Standardwerten versehen werden können
\end{itemize}


\subsubsection{Bequemlichkeitsmethode (engl. convenience method)}
\definition[0]{Bequemlichkeitsmethode}{vereinfacht den Methodenaufruf durch die bereitstellung häufig genutzter Parameterkombinationen in zusätzlichen Methoden ($\Rightarrow$Überladen), basically fast das gleiche wie Bequemlichkeitsklasse.}
\fig{Bequemlichkeitsmethodenmusterstruktur}{./data/entwurfsmuster/bequemlichkeitsmuster/bequemlichkeitsmethode.png}
Anwendbar, wenn Methodenaufrufe häufig mit den gleichen Parametern auftreten.


\subsubsection{Fassade}
\definition[0]{Fassade}{Einheitliche Schnittstelle zu einer Menge von Schnittstellen bieten}
\fig{Fassadenmusterstruktur}{./data/entwurfsmuster/bequemlichkeitsmuster/fassade.png}
Anwendbar, wenn
\begin{itemize}
    \item eine einfache Schnittstelle zu einem komplexen Subsystem angeboten werden soll
    \item es viele Abhängigkeiten zwischen Klient und Implementierung einer Abstraktion gibt. Die Fassade entkoppelt die Subsysteme von Klienten und anderen Subsystemen
\end{itemize}

\newpage
\subsubsection{Null-Objekt}
\definition[0]{Null-Objekt}{stellt einen \important{Stellvertreter} zur Verfügung, der die gleiche Schnittstelle bietet, aber nichts tut. Das Null-Objekt kapselt die Implementierungsentscheidung (wie genau es \anfuehrung{nichts tut}) und versteckt diese Details vor seinen Mitarbeitern.}
Zeilen wie:\\
\texttt{\textcolor{purple}{if} (\textcolor{ForestGreen}{thisCall}.\textcolor{blue}{callingParty} != \textcolor{purple}{null}) \textcolor{ForestGreen}{thisCall}.\textcolor{blue}{callingParty}.action();}\\
werden somit vermieden.\\
\fig{Struktur eines Nullobjekts}{./data/entwurfsmuster/bequemlichkeitsmuster/nullobjekt.png}

Anwendbar, wenn...
\begin{itemize}
    \item ein Objekt Mitarbeiter benötigt und einer oder mehrere von ihnen nichts tun sollen
    \item Klienten sich nicht um den Unterschied zwischen einem echten Mitarbeiter und einem der nichts tut kümmern sollen
    \item das „tue nichts“-Verhalten von verschiedenen Klienten wiederverwendet werden soll
\end{itemize}