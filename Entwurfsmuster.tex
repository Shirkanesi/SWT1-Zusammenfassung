\section{Entwurfsmuster}
\definition[0]{Software-Entwurfsmuster}{Ein Software-Entwurfsmuster beschreibt eine Familie von \important{Lösungen} für ein Software-\important{Entwurfsproblem}.}
\anmerkung[0]{}{Der Zweck von Entwurfsmustern ist die Wiederverwendung von Entwurfswissen.}

\subsection{Entkopplungsmuster}
\definition[1]{Entkopplungs-Muster}{Entkopplungsmuster teilen ein System in mehrere Einheiten, so dass einzelne Einheiten unabhängig voneinander erstellt, verändert, ausgetauscht und wiederverwendet werden können. Der Vorteil von Entkopplungsmustern ist, dass ein System durch lokale Änderungen verbessert, angepasst und erweitert werden kann, ohne das ganze System zu modifizieren.}
% Adapter
\subsubsection{Adapter}
\definition[0]{Adapter}{Passt die Schnittstelle einer Klasse an eine Andere von ihren Klienten erwartete Schnittstelle an.}
\anmerkung[0]{}{$\Rightarrow$ Klassen können zusammenarbeiten, die wegen inkompatibler Schnittstelle ansonsten nicht in der Lage wären.}
\fig{Adapter ohne Mehrfachvererbung}{data/entwurfsmuster/adapter_1.png}
\fig{Adapter mit Mehrfachvererbung}{data/entwurfsmuster/adapter_2.png}

\subsubsection{Beobachter / Observer}
\definition[0]{Beobachter}{Ein Beobachter beobachtet ein Objekt und informiert andere Objekte über Änderungen an diesem.}
\anmerkung[0]{}{Ein Beobachter definiert eine 1-zu-n Abhängigkeit zwischen Objekten, so dass die Änderung eines Zustandes eines Objektes dazu führt, dass alle abhängigen Objekte benachrichtigt und automatisch aktualisiert werden.}
\newline
\fig{Struktur eines Beobachters}{data/entwurfsmuster/observer_1.png}
\newline
\fig{Beobachter - Beispiel aus Java}{data/entwurfsmuster/observer_2.png}
\anmerkung[0]{Anwendbarkeit}{Wenn die Änderung eines Objekts die Änderung anderer Objekte verlangt und man nicht weiß, wie viele und welche Objekte geändert werden müssen.}
\anmerkung[1]{}{Wenn ein Objekt andere Objekte benachrichtigen muss, ohne Annahmen über diese Objekte zu treffen.}
\anmerkung[0]{Konsequenzen}{Beobachter können neu hinzugefügtoder entferntwerden, ohnedas Subjekt oder andere Beobachter zu ändern}
 
 \subsubsection{Brücke / Bridge}
 \definition[0]{Zweck}{Trennt Abstraktion von ihrer Implementierung, sodass beide unabhängig voneinander variiert werden können}
 \fig{Brücke}{data/entwurfsmuster/bridge.png}
 \\
 Anwendbarkeit:
 \begin{itemize}
     \item Wenn eine dauerhafte Verbindung zwischen Abstraktion und Implementierung vermieden werden soll
     \item Wenn Erweiterbarkeit durch Unterklassen für beide Seiten gefordert ist
     \item Wenn Änderungen der Implementierung einer Abstraktion keine Auswirkung auf Klienten haben soll
     \item Wenn die Implementierung der Abstraktion vollständig vom Klienten versteckt werden sollen.
 \end{itemize}
 
 
 \fig{Beispiel für ein Brückenmuster}{data/entwurfsmuster/bridge_example.png}
 
 
\subsubsection{Iterator}
Ein Iterator ermöglicht einen \important{sequentiellen Zugriff} auf die Elemente eines zusammengesetzten Objektes, ohne seine zugrundeliegendes Repräsentation offenzulegen.
\newline
\fig{Struktur eines Iterators}{data/entwurfsmuster/iterator_1.png}
\warn[0]{}{Ein funktioniert immer sequenziell}
\anmerkung[1]{}{Das momentane Element kann aus der Datenstruktur entfernt werden.}
\anmerkung[0]{Anwendbarkeit}{Um den Zugriff auf den Inhalt eines zusammengesetzten Objekts zu ermöglichen, ohne dabei seine interne Struktur offenzulegen.}
\anmerkung[0]{}{Robustist der Iterator, weil er gleichzeitig mehrere Traversierungen ermöglicht. Jeder Iterator enthält eine eigene „Laufvariable“.}

\subsubsection{Stellvertreter / Proxy}
\definition[0]{Stellvertreter}{Ein Proxy kontrolliert den Zugriff auf ein Objekt mit Hilfe eines vorgelagerten \important{Stellvertreterobjekts}}